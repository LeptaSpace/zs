TODO

OK - register function types
OK - provide input/output to call API
OK - add VALUE/PHRASE/SENTENCE atomics


user functions take type of first function


register atomic, set type
    strict, lazy, greedy

parsing sentence:
    - start phrase at beginning
    - "," ends previous phrase and starts new one
    - sentence output is held as own list
    - "." ends sentence (prints sentence output)
    - ")" ends sentence (unnest, send to parent)

parsing function
    - lookup name and get type
    - if followed by "(" then push sentence and start new one
    - resolve function type to: PURE, LAZY, WEAK
    - phrase state: empty (start), or busy (middle)

    start-of-phrase:
        pure
            eat sentence
            execute function
        lazy
            eat phrase
            execute function
        weak
            input is null
            execute function

    busy-with-phrase:
        pure
            eat phrase
            execute function
        lazy
            eat value
            execute function
        weak
            input is null
            execute function

    atomics
        NEST
        UNNEST
        NOM         - EAT VALUE
        NOMNOM      - EAT PHRASE (current or previous)
        NOMNOMNOM   - EAT SENTENCE



computations

    choices                                             parsing     surprise    set
        infix notation      a - b + c                     *          *****       *
            with parens     a - (b + c)                   *          ****        *
            or without      automatic priority
        postfix notation    a b - c +                     **          **         *
            order?          a - b or b - a?
        function notation   + (- (a b) c)                 ****         *       *****
        comma notation      a b, - c, +                   ****         *       *****

    answer: make operators as functions/atomics
        + * / - % ^

    answer: allow a b, - c, +

if atomic is called on line by itself
    then show hint
        perhaps registration tweak to allow function to run on empty data
if atomic is called with empty list
    then run atomic?

provide atomics with input & output pipe automatically:
    zs_pipe_t *input, zs_pipe_t *output

    if called inline
        input is null
        if output has values
            can behave as unary function
            pull & send last value
        if output is empty
            then do what?

    if called on list
        input provides list




help on function
    how to put function onto pipe
    ? xyz

help (xyz)
    get hint on xyz if it's an atomic
    else show code for xyz if it's a function

    -> how do we know to pass a function rather than execute it?
    1. @ before function name
    2. atomic can force this


0, 1 many - conditionals and loops are the same; we repeat a phrase N times

    compute { execute }
    5 { <*> <*> <*>}

    forever { sleep (1) temperature }
    until (12 PM) { sleep (1) temperature }

    Event driven:
        above (30 C) { cooling (on) }
        below (15 C) { heating (on) }


Comments

    #   starts a comment until the end of the line
        no multiline comments

Numbers and units

    expressive number support


Multiline strings
    <
    some value
    >

    <
some value
>

Multi-line indented strings
    <
    some value
    and another value
    and then more
    >

string atomics
    1, many
        upper
        lower
        camel
        title
        slug
        size

    many
        paste
        sort
        first
        last

    2
        find        (find string in another)
        split       (split string into tokens)
        count       (count string in another)
        repeat      (repeat string N times)
        match       (string vs. pattern or pattern vs. string)
        replace     (string mashing,...)

