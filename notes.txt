TODO

Problem: should not change pipes for user defined FN

Problem: REPL shows continuation after fn definition
Problem: how to compile & run a paper script
Problem: define test case for each atomic, in ZS
Problem: function compilation too complex
    - get type, use type -> single call to VM
Problem: period doesn't work for <fn: (sum). fn (1 2 3)>


-- when do we wipe input?
    1 2 3 xx yy zz?

    fn: (sum)
    fn (1 2 3) -> 0

        -> because sum is greedy
        ... greedy/anything after unnest nop
        ... or don't wipe input?


sum (1)

    output: 1
    unnest: append to previous output
    sum:

fn: (sum)
fn (1)
    output: 1



- array functions like modest...
    1 2 +
    - input is 2 1
    1 2, 3 +
    - input is 3 1 2

    fn: (1000 *)

        - what's the input?
        - 1000 is constant, skip it
        - * is array, so fn is array?
    >> how to get current phrase as input to function ()?



- make core atomics work with reals
    - start with whole
    - if we hit any real, then flip to real loop
    - strings...? **for later**

- selftests for atomics

- make zs_repl into an actor
    - accept input on pipe
    - return output to pipe (end of sentence)

- user functions take type of first function

- profile every function, simple counter, 'n top' atomic sorts & prints top n

- expressive constants: 1/2 1:2 2^16-1 1024*1024
    contain + - /: *x ^
    simple stack-based evaluator in zs_lex

help on function
    how to put function onto pipe
    ? xyz

help (xyz)
    get hint on xyz if it's an atomic
    else show code for xyz if it's a function

    -> how do we know to pass a function rather than execute it?
    1. @ before function name
    2. atomic can force this


0, 1 many - conditionals and loops are the same; we repeat a phrase N times

    compute { execute }
    5 { <*> <*> <*>}

    forever { sleep (1) temperature }
    until (12 PM) { sleep (1) temperature }

    Event driven:
        above (30 C) { cooling (on) }
        below (15 C) { heating (on) }



Multiline strings
    <
    some value
    >

    <
some value
>

Multi-line indented strings
    <
    some value
    and another value
    and then more
    >


string atomics
    1, many
        upper
        lower
        camel
        title
        slug
        size

    many
        paste
        sort
        first
        last

    2
        find        (find string in another)
        split       (split string into tokens)
        count       (count string in another)
        repeat      (repeat string N times)
        match       (string vs. pattern or pattern vs. string)
        replace     (string mashing,...)
