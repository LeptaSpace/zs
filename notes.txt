TODO

Problem: need loops and conditionals


    compile start of cycle

        VM_START
            [nnnn]




    I'd like the VM to invoke a function that emits yes/no to whether to do the block.
    Question is how this function holds its state

        fn (args) { phrase }
        args fn { phrase }
        number { phrase }

    for numbers
        - push constant to output
            - yes/no indicator
            - eat one output
            - execute optional cycle
            - or skip to end
            REPEAT:
                - push repeat address to vm
            { store all code }
            AGAIN:
                - store exit address

            VM_REPEAT
            [0000]  - skip address
            code code code




    for functions
        - invoke function as usual
        - function provides output
            - yes/no indicator
            - further state if any
            - eat one output, push rest
            - execute optional cycle
            - pop output -> input
            - invoke function on new output

    for strings
        - unknown

    args are provide to fn on first invocation, then fn output is passed back to fn
    at each other invocation. FN outputs yes/no plus own state.

    lets model simple N times loop

        times (10) { <hello> }

        10 times { <hello> }
        { 10 times <hello> }
        { temperature if <hello> }


    call times nested
        send 10 to output
        unnest, pull 10 to input
        call times

            times: ( 1/0 1 - )

        sends 9 to output

            nest output
            invoke phrase
            unnes output -> input 9
        call times
        sends 8 to output




    5 { ... }
    function { ... }

    where function produces 0..1..N times
        call function again each time?
        or call just once?

    if () { }           1/0 one time
    when ( ) { }        1/0 one time
    else { }            ... mystical
    repeat ( ) { }      ... N one time
    until ( ) { }       ... mystical
    maybe ( ) { }       ... mystical





Problem: how to compile & run a paper script
Problem: define test case for each atomic, in ZS



atomic contracts:
    hint
    status (draft, stable, legacy)
    testcase (text)

selftests run through all atomic tests
    then for functions:
        hint (<something>)
        selftest (<something>)
        status (stable|draft|legacy)



- rewrite shell as repl primitive
    - read line of input, put onto pipe
    - execute input, display results if any
    - core of zs.c

- then shell is
    until (break) { repl }


- repl primitive takes list of lines, executes

- rewrite scaling primitives in ZS?
<
    k: (<Multiply by 1000> 1000 *)
    M: (<Multiply by 1M> 1000000 *)
> repl
    - default for * is "multiple by 1"?
    - how to add hint for function....
    k: <Multiply by 1000> (1000 *)

- increase function address space to 32 bits (now 16 bits)

- pipes can probably be built as single tree structure?

- make zs_repl into an actor
    - accept input on pipe
    - return output to pipe (end of sentence)

- profile every function, simple counter, 'n top' atomic sorts & prints top n

- expressive constants: 1/2 1:2 2^16-1 1024*1024
    contain + - /: *x ^
    simple stack-based evaluator in zs_lex

help on function
    how to put function reference onto pipe
    (function)
    now (function) now -
    now (function (args)) now -

help (xyz)
    get hint on xyz if it's an atomic
    else show code for xyz if it's a function

    -> how do we know to pass a function rather than execute it?
    1. @ before function name
    2. atomic can force this



Multiline strings
    <
    some value
    >

    <
some value
>

Multi-line indented strings
    <
    some value
    and another value
    and then more
    >


string atomics
    1, many
        upper
        lower
        camel
        title
        slug
        size

    many
        paste
        sort
        first
        last

    2
        find        (find string in another)
        split       (split string into tokens)
        count       (count string in another)
        repeat      (repeat string N times)
        match       (string vs. pattern or pattern vs. string)
        replace     (string mashing,...)
