TODO

- allow comments starting with '#', to end of line*

- allow symbolic operators (+, *, etc.)

- arithmetic functions have to support reals

- coerce modest function to strict
    - if input is empty, assume 1
    - k -> 1000

- make zs_repl into an actor
    - accept input on pipe
    - return output to pipe (end of sentence)

- array functions
    - modest function that takes additional subjects
    - register type zs_type_array
    - syntax: inputs, operands fn
    - alternative:  fn (operands)
        e.g.    n times
                1 2 3, 2 times
                2 times (1 2 3)
    - 2 3, times (1 2 3) ???
    - receive on input pipe, separated by mark

    list functions: avg, sum, min, max, count, product
    array functions: plus +, minus -, times * x, divide / :, power ^, ...

- user functions take type of first function

- profile every function, simple counter, 'n top' atomic sorts & prints top n

help on function
    how to put function onto pipe
    ? xyz

help (xyz)
    get hint on xyz if it's an atomic
    else show code for xyz if it's a function

    -> how do we know to pass a function rather than execute it?
    1. @ before function name
    2. atomic can force this


0, 1 many - conditionals and loops are the same; we repeat a phrase N times

    compute { execute }
    5 { <*> <*> <*>}

    forever { sleep (1) temperature }
    until (12 PM) { sleep (1) temperature }

    Event driven:
        above (30 C) { cooling (on) }
        below (15 C) { heating (on) }



Multiline strings
    <
    some value
    >

    <
some value
>

Multi-line indented strings
    <
    some value
    and another value
    and then more
    >


string atomics
    1, many
        upper
        lower
        camel
        title
        slug
        size

    many
        paste
        sort
        first
        last

    2
        find        (find string in another)
        split       (split string into tokens)
        count       (count string in another)
        repeat      (repeat string N times)
        match       (string vs. pattern or pattern vs. string)
        replace     (string mashing,...)
