TODO

Problem: need loops and conditionals

    gearing { sentence }

    gearing:
        0 or 1 times maybe (match)
            <string> { sentence }
            -- if pattern matches previous value execute sentence
            -- else eat pattern and value
            -- need atomic to duplicate value: "default"
                -- eat all input and issue 1

            ? <string> { sentence }
            ? <string> { sentence }
              default { sentence }
              -- this should be a choice, events in a state
                 or case in a switch... not logical flow...
              -- how do we mark start and end of this?

            ** let's just start with simple conditional **

        N times constant
            number { sentence }
            -- repeat sentence number times

        V times variable
            function { sentence }
            -- function produces true/false
            -- execute or skip sentence accordingly

        tokens:
            string {        gear-match
            number {        gear-spin
            function {      gear-repeat
            }               gear-close



More like a grammar...

    [ fubar snafu ]
    *1( fubar snafu )
    0*1 ( fubar snafu )

Conditional: pattern matching

    - take value on pipe
    - match against pattern
    - when, do...


    pattern matching?



    forever: { 1 }


    phrase { phrase... }

    100 { <*> }

    forever { sleep (1) <yawn> }

    until (12 PM) { sleep (1) temperature }



0, 1 many - conditionals and loops are the same; we repeat a phrase N times

    compute { execute }
    5 { <*> <*> <*> }

    forever { sleep (1) temperature }
    until (12 PM) { sleep (1) temperature }

    Event driven:
        above (30 C) { cooling (on) }
        below (15 C) { heating (on) }


Problem: how to compile & run a paper script
Problem: define test case for each atomic, in ZS



atomic contracts:
    hint
    status (draft, stable, legacy)
    testcase (text)

selftests run through all atomic tests
    then for functions:
        hint (<something>)
        selftest (<something>)
        status (stable|draft|legacy)



- rewrite shell as repl primitive
    - read line of input, put onto pipe
    - execute input, display results if any
    - core of zs.c

- then shell is
    until (break) { repl }


- repl primitive takes list of lines, executes

- rewrite scaling primitives in ZS?
<
    k: (<Multiply by 1000> 1000 *)
    M: (<Multiply by 1M> 1000000 *)
> repl
    - default for * is "multiple by 1"?
    - how to add hint for function....
    k: <Multiply by 1000> (1000 *)

- pipes can probably be built as single tree structure?

- make zs_repl into an actor
    - accept input on pipe
    - return output to pipe (end of sentence)

- profile every function, simple counter, 'n top' atomic sorts & prints top n

- expressive constants: 1/2 1:2 2^16-1 1024*1024
    contain + - /: *x ^
    simple stack-based evaluator in zs_lex

help on function
    how to put function reference onto pipe
    (function)
    now (function) now -
    now (function (args)) now -

help (xyz)
    get hint on xyz if it's an atomic
    else show code for xyz if it's a function

    -> how do we know to pass a function rather than execute it?
    1. @ before function name
    2. atomic can force this



Multiline strings
    <
    some value
    >

    <
some value
>

Multi-line indented strings
    <
    some value
    and another value
    and then more
    >


string atomics
    1, many
        upper
        lower
        camel
        title
        slug
        size

    many
        paste
        sort
        first
        last

    2
        find        (find string in another)
        split       (split string into tokens)
        count       (count string in another)
        repeat      (repeat string N times)
        match       (string vs. pattern or pattern vs. string)
        replace     (string mashing,...)
